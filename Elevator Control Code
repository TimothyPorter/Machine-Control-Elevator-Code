#pragma config(Sensor, dgtl1,  floor1bump,     sensorTouch)
#pragma config(Sensor, dgtl2,  floor2bump,     sensorTouch)
#pragma config(Sensor, dgtl3,  floor3bump,     sensorTouch)
#pragma config(Sensor, dgtl4,  sonar,          sensorSONAR_inch)
#pragma config(Sensor, dgtl6,  floor2LED,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl7,  floor1LED,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  floor3LED,      sensorLEDtoVCC)
#pragma config(Motor,  port2,           elevator,      tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int floorPrecision = 0;																		//Set needed precision for arriving at a floor

int priorityQueue[5] = {0, 0, 0, 0, 0};										//Create a queue for floors, 5 digets long
int lastFrameBumpsPressed[3] = {0, 0, 0};									//Create array to keep track of which buttons are depressed
int nextFloorHeight;																			//Create variable to store height of next floor
bool movingToNewFloor = false;														//Create boolean to say if elevator is headed to a floor
bool waitingAtFloor = false;															//Create boolean to say if elevator is stopped at floor


void ArriveAtFloor();																			//Create ArriveAtFloorMethod
int Dequeue ();																						//Create Dequeue Method


void StartTripToFloor(int nextFloor){											//Create StartTripToFloor method with argument int nextFloor
	movingToNewFloor = true;																	//Set variable of moving to floor to true
	switch(nextFloor){																				//Start switch statement with variable nextFloor
		case 1:																									//If Next Floor is 1
			nextFloorHeight = 0;																	//Set NextFloorHeight to 0
			break;																								//Break out of switch statement
		case 2:																									//If Next Floor is 2
			nextFloorHeight = 5;																	//Set NextFloorHeight to 4
			break;																								//Break out of switch statement
		case 3:																									//If Next Floor is 3
			nextFloorHeight = 9;																	//Set NextFloorHeight to 9
			break;																								//Break out of switch statement
	}

	int distance = SensorValue(sonar);												//Set new variable distance to distance between sonar and elevator
	distance = (distance >= 200) ? 0 : distance;							//If sonar value is above 200, set distance variable to 0
	if(distance > nextFloorHeight + floorPrecision) {					//If distance above sonar is greater than next floor height plus floor precision
		startMotor(elevator, -25);															//Start elevator motor with speed -25
		} else if (distance < nextFloorHeight - floorPrecision){//If distance above sonar is less than next floor height minus floor precision
		startMotor(elevator, 25);																//Start elevator motor with speed 25
		} else {																								//Otherwise
		ArriveAtFloor();																				//Call functions ArriveAtFloor
	}
}
void ArriveAtFloor(){																			//Create function ArriveAtFloor
	stopMotor(elevator);																			//Stop elevator motor
	movingToNewFloor = false;																	//Set moving to next floor to false
	waitingAtFloor = true;																		//Set waiting at floor to true
	clearTimer(T1);																						//Start timing on timer T1
}

void Enqueue (int newFloor){															//Create function Enqueue with argument int newFloor
	bool enqueued = false;																		//Create boolean enqueued with value false
	int queuePlace = 0;																				//Start counter for queue placement starting at 0
	while(!enqueued && queuePlace < 5){												//While new floor is not enqueued and queue place does not exceed queue size
		if(priorityQueue[queuePlace] == 0){											//If current place in queue does not have a value
			priorityQueue[queuePlace] = newFloor;									//Set value in priority queue to new floor
			enqueued = true;																			//Change variable enqueued to true
		}
		queuePlace++;																						//Increment queue placement
	}
}
int Dequeue (){																						//Create function Dequeue
	int returnValue = priorityQueue[0];												//Store first value in priority queue as returnValue
	for(int i = 0; i < 4; i++){																//For each value i in priority queue
		priorityQueue[i] = priorityQueue[i + 1];								//Set value of priority queue at i to next value in queue
	}
	priorityQueue[4] = 0;																			//Set final value in queue to 0
	return returnValue;																				//Have function return stored value
}
void LEDControl(int distance){														//Create function LEDControl
	bool LEDs[] = {true, true, true};													//Create array to store if LEDs should be on
	if(distance < 5){																					//If distance is less than 4
		turnLEDOn(floor1LED);																		//Turn on floor 1 LED
	} else {																									//Otherwise
		turnLEDOff(floor1LED);																	//Turn floor 1 LED off
	}
	if(distance > 0 && distance < 9){													//If distance is less than 9 and greater than 0
		turnLEDOn(floor2LED);																		//Turn on floor 2 LED
	} else {																									//Otherwise
		turnLEDOff(floor2LED);																	//Turn floor 2 LED off
	}
	if(distance > 5){																					//If distance is greater than 4
		turnLEDOn(floor3LED);																		//Turn on floor 3 LED
	} else {																									//Otherwise
		turnLEDOff(floor3LED);																	//Turn floor 3 LED off
	}
}


task main()																								//Start main function
{
	while(true){																							//While always

		int distance = SensorValue(sonar);											//Store sensor value as variable distance
		distance = (distance >= 200) ? 0 : distance;						//If distance is in excess of 200, set value to 0
		LEDControl(distance);


		if(SensorValue(floor1bump) == 1){												//If bump switch 1 is being pressed
			if(lastFrameBumpsPressed[0] == 0){										//If bump switch 1 was not pressed last frame
				Enqueue(1);																					//Enqueue floor 1
				wait(0.2);																					//Wait 0.1 seconds
				lastFrameBumpsPressed[0] = 1;												//Store that bump switch 1 was pressed this frame
			}
		} else {																								//Otherwise
			lastFrameBumpsPressed[0] = 0;													//Store that bump switch 1 was not pressed this frame
		}
		if(SensorValue(floor2bump) == 1){												//If bump switch 2 is being pressed
			if(lastFrameBumpsPressed[1] == 0){										//If bump switch 2 was not pressed last frame
				Enqueue(2);																					//Enqueue floor 2
				wait(0.2);																					//Wait 0.1 seconds
				lastFrameBumpsPressed[1] = 1;												//Store that bump switch 2 was pressed this frame
			}
		} else {																								//Otherwise
			lastFrameBumpsPressed[1] = 0;													//Store that bump switch 1 was not pressed this frame
		}
		if(SensorValue(floor3bump) == 1){												//If bump switch 3 is being pressed
			if(lastFrameBumpsPressed[2] == 0){										//If bump switch 3 was not pressed last frame
				Enqueue(3);																					//Enqueue floor 3
				wait(0.2);																					//Wait 0.1 seconds
				lastFrameBumpsPressed[2] = 1;												//Store that bump switch 3 was pressed this frame
			}
		} else {																								//Otherwise
			lastFrameBumpsPressed[2] = 0;													//Store that bump switch 3 was not pressed this frame
		}

		if(waitingAtFloor && time1(T1) >= 1000){								//If waiting at floor and T1 timer exceeds 1000 milliseconds
			waitingAtFloor = false;																//Set waiting at floor to false
			clearTimer(T2);																				//Start timing on timer T2
		}
		if(time1(T2) >= 10000 && !waitingAtFloor && !movingToNewFloor){//If timer T2 exceeds 10000 milliseconds and not waiting at floor or moving to new floor
			StartTripToFloor(1);																	//Start moving to floor 1
		}


		if(priorityQueue[0] != 0 && !waitingAtFloor && !movingToNewFloor){//If first value in priority queue is not empty and not waiting at floor or moving to new floor
			StartTripToFloor(Dequeue());													//Dequeue from priority queue and start trip to that floor
		}

		if(abs(distance - nextFloorHeight) <= floorPrecision && movingToNewFloor){//If difference between current height and next floor height is more than floor precision and moving to new floor
			ArriveAtFloor();																			//Arrive at current floor
		}
	}
}
